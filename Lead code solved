# 3 longest substring without repeating characters

s="pwwkew"
list1=[]
x=1
n=0
while n<len(s):
    s1=s[n]

    for i in range(x, len(s)):
        if s[i] not in s1:
            s1=s1+s[i]
            print(s1)
            list1.append(s1)
        else:
            break
    x=x+1
    n=n+1
        
list1=[len(x) for x in list1]
list1
print(max(list1))


#zero based permutation

n=6
nums=[0,2,1,5,3,4]

def result(nums):
    n=len(nums)
    ans=[0]*(n)
    for i in range(0,len(nums)):
        ans[i]=nums[nums[i]]
        
    return ans
    
result(nums)

#running sum


nums=[1,2,3,4]

def runningsum(nums):
    n=len(nums)
    runningsum=[0]*(n)
    for i in range(0,len(nums)):
        runningsum[i]=sum(nums[0:i+1])
        
    return runningsum
    
runningsum(nums)


#final value of variable after performing opertaions


operations=["X--","X++","++X"]
x=0

def result(nums,x):
           
    for i in operations:
        if i=="X++":
            x=x+1
        elif i=="++X":
            x+=1
        elif i=="X--":
            x=x-1
        else:
            x=x-1
            
         
        
    return x
    
result(nums,x)


#richest customer wealth



accounts=[[10,15,25],[25,10,45],[5,5,5],[45,60,40],[4,10,8]]


wealth1=0
for x in accounts:
    wealth=sum(x)
    if wealth>wealth1:
        wealth1=wealth
print(wealth1)    
    
    
# maximum number of words found in a sentence

sentences=["sean is a good boy","he has a really kind heart","lord saif","he he he he he he he"]

l1=0
count1=0
for x in sentences:
    n=1
    
    for y in x:
        if y==" ":
            n=n+1
    count=n
    if count>count1:
        count1=count
        
print(count1)
        
        
        
# shuffle the array

nums=[1,2,3,4,5,6]

def shuffle(nums):
    n=len(nums)//2
    nums1=[0]*6

    j=0
    k=1
    for i in range(0,n):
        nums1[j]=nums[i]
        j=j+2
    for i in range(n,2*n):
        nums1[k]=nums[i]
        k=k+2
    return nums1   

shuffle(nums)





#number of good pairs

nums=[1,2,3,1,1,3]

n=len(nums)

x=1
count=0

for i in range(0, len(nums)-1):
    for j in range(x, len(nums)):
        if (nums[i]==nums[j]) and (i<j):
            count=count+1
            print(i,j)            
    x=x+1
    
print(count)



#kids with greatest number of candies

candies = [2,3,5,1,3]
n=len(candies)
extraCandies = 3
result=[0]*n

g=max(candies)

for i in range(0,len(candies)):
    x=candies[i]+3
    if x>=g:
        result[i]=True
    else:
        result[i]=False
        
print(result)



#how many numbers are smaller than current number

nums = [8,1,2,2,3]
n=len(nums)
result=[0]*n
x=1

for i in range(0,n):
    count=0
    for j in range(0,n):
        if (nums[i]>nums[j]) and (i!=j):
            count=count+1
    result[i]=count
    x=x+1
    
print(result)


#decompress run-length encoded list

nums = [[1,2],[3,4]]
nums1=[1,2,3,4]

dlist=[]

for x in nums:
    f=x[0]
    v=x[1]
    dl=[v]*f
    dlist.append(dl)
    


dlist = [j for i in dlist for j in i]

dlist
    
    
#shuffle string

s = "codeleet"
indices = [4,5,6,7,0,1,2,3]

s = "abc"
indices = [0,1,2]

ans=""

for i in range(0,len(indices)):
    ans=ans+s[indices[i]]
    
ans
    
    
    
#count items matching a rule

items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]]
ruleKey = "type"
ruleValue = "phone"

count=0

if ruleKey=="type":
    x=0
    
if ruleKey=="color":
    x=1
    
if ruleKey=="name":
    x=2
    

for i in items:
    if i[x]==ruleValue:
        count=count+1
        
        
print(count)
        
    
#sum of all odd length subarray

arr = [1,4,2,5,3]
n=len(arr)
l=1
running_sum=0



while l<=n:
    z=0
    y=l
    while y<=n:
        running_sum=running_sum+sum(arr[z:y])
        z=z+1
        y=y+1
    l=l+2
    
print(running_sum)




# minimum number of seats to seat everyone

seats = [3,1,5]
students = [2,7,4]

seats.sort()
students.sort()

print(seats)
print(students)

import numpy as np

array1 = np.array(seats)
array2 = np.array(students)
subtracted_array = np.subtract(array1, array2)
subtracted = list(subtracted_array)
print(subtracted)

abs(sum(subtracted))


#island parameter

grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]

perimeter=0

for i in range(0,len(grid)):
    for j in range(0,len(grid[0])):
        
        if grid[i][j]==1:
            temp=4
            if j-1>=0:
                if grid[i][j-1]==1:
                    temp=temp-1
            if j+1<len(grid[i]):
                if grid[i][j+1]==1:
                    temp=temp-1
            if  i-1>=0:
                if grid[i-1][j]==1:
                    temp=temp-1
            if  i+1<len(grid):
                if grid[i+1][j]==1:
                    temp=temp-1
        else:
            temp=0
        perimeter=perimeter+temp
        
        
                
            
print(perimeter)



#flood fill

image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1
sc = 1
color = 2
x=image[sr][sc]

def floodfill(matrix,sr,sc,color):
    
    matrix[sr][sc]=color
    
    if sc-1>=0:
        if matrix[sr][sc-1]==x:
             matrix[sr][sc-1]=color
    if sc+1<len(matrix[sr]):
        if matrix[sr][sc+1]==x:
             matrix[sr][sc+1]=color
    if sr-1>=0:
        if matrix[sr-1][sc]==x:
            matrix[sr-1][sc]=color
    if sr+1<len(matrix):
        if matrix[sr+1][sc]==x:
            matrix[sr+1][sc]=color
    
            
            
def floodfill1(matrix,sr,sc,color):
    if sc-1>=0:
        if matrix[sr][sc-1]==x:
             floodfill(image,sr,sc-1,color)
    if sc+1<len(matrix[sr]):
        if matrix[sr][sc+1]==x:
              floodfill(image,sr,sc+1,color)
    if sr-1>=0:
        if matrix[sr-1][sc]==x:
             floodfill(image,sr-1,sc,color)
    if sr+1<len(matrix):
        if matrix[sr+1][sc]==x:
             floodfill(image,sr+1,sc,color)
    
            
 # Find a Corresponding Node of a Binary Tree in a Clone of That Tree

class Node:
    def __init__(self,data):
        self.data=data
        self.left=None
        self.right=None
        
#create the trees
        
root=Node(7)
temp=Node(4)
root.left=temp
target=Node(3)
root.right=target
temp=Node(6)
root.right.left=temp
temp=Node(19)
root.right.right=temp



root1=Node(7)
temp=Node(4)
root1.left=temp
temp=Node(3)
root1.right=temp
temp=Node(6)
root1.right.left=temp
temp=Node(19)
root1.right.right=temp


def traverse(node,target):
    if node:
        traverse(node.left,target)
    
        if node.data==target.data:
            print("corresponding node address is :",node)
            return 
        traverse(node.right,target)
    
traverse(root1,target)

print(root1.right)
    
    
#inorder traversal 

class Node:
    def __init__(self,data):
        self.data=data
        self.left=None
        self.right=None
        
#create the trees
        
root=Node(7)
temp=Node(4)
root.left=temp
target=Node(3)
root.right=target
temp=Node(6)
root.right.left=temp
temp=Node(19)
root.right.right=temp
temp=Node(7)
root.left.right=temp
temp=Node(9)
root.left.left=temp




def traverse(node):
    if node:
        traverse(node.left)
    
        print(node.data)
        traverse(node.right)
    
traverse(root)
    
    
    
# Range sum of BST

class Node:
    def __init__(self,data):
        self.data=data
        self.left=None
        self.right=None
        

root=Node(10)
temp=Node(5)
root.left=temp
temp=Node(15)
root.right=temp
temp=Node(18)
root.right.right=temp
temp=Node(7)
root.left.right=temp
temp=Node(3)
root.left.left=temp

sum=0

def traverse(node,low,high):
    global sum
    if node:
        traverse(node.left,low,high)
        if node.data>=low and node.data<=high:
            sum=sum+node.data
        traverse(node.right,low,high)
    
traverse(root,7,15)
print(sum) 
    
